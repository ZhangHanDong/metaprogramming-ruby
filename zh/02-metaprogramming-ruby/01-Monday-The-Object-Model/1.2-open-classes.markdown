1.2 开放类(Open Classes)
----------------

*这里比尔带你第一次品味Ruby的类*

在你和比尔浏览了Bookworm源码几分钟以后，你提出了第一个需要重构的地方。Bookworm有一个函数，剥离了一个字符串的所有标点符号和特殊符号，仅仅留下字母数字和空格:

    def to_alphanumeric(s)
      s.gsub /[^\w\s]/, ''
    end
    
这个方法的单元测试:

    require 'test/unit'
    class ToAlphanumericTest < Test::Unit::TestCase
      def test_strips_non_alphanumeric_characters
        assert_equal '3 the Magic Number' , to_alphanumeric('#3, the *Magic, Number*?' )
      end
    end
    
“这个to_alphanumeric( )方法不是很面向对象，是不是？”， 比尔来灵感了，“如果我们能让这个字符串转换它自己，应该比把它传给一个方法好的多。”

虽然你是个新手，无法提供帮助，但是你插嘴道：“但是这只是一个字符串正则表达式。去为它增加方法，我们不得不去写一个新的AlphanumericString类。我不确定这样做值不值得。”

“我想我有一个更简单的方法解决这个问题”， 比尔回答。 它打开了String类， 并且把to_alphanumeric( )放置到那里：

    class String
      def to_alphanumeric
        gsub /[^\w\s]/, ''
      end
    end

比尔也改变了String#to_alphanumeric( )的调用者. 例如，单元测试变成了下面形式:

    require 'test/unit'
      class StringExtensionsTest < Test::Unit::TestCase
        def test_strips_non_alphanumeric_characters
          assert_equal '3 the Magic Number' , '#3, the *Magic, Number*?'.to_alphanumeric
        end
      end

我们需要了解一些关于Ruby类的知识才能理解比尔的技巧。 比尔很乐意去教你 。。。

**深入类定义(Inside Class Definitions)**

在Ruby中， 定义一个类的代码，和其他代码没有什么差别。你可以把任意代码放置到你想放置的类定义中， 就像比尔演示的这个例子:

    3.times do
      class C
        puts "Hello"
      end
    end
    => Hello
       Hello
       Hello


>你应该把你的方法放到哪里?

>在1.2节, 开放类的28页, 比尔演示了如何把to_alphanumeric( )方法移动到String类里。
>但是即使你能这样做，你可能也想知道你是否应该这样做。给系统中的每一个字符串都暴露一个to_alphanumeric( )方法？
>should do it. Is it right to have every string in the system expose
>a to_alphanumeric( ) method? Wouldn’t it be better to leave the
>String class alone?
>This time around, you’re dealing with a pretty generic functionality
>that makes sense for all strings—so you can argue it
>makes sense to follow Bill’s suggestion and put alphanumeric
>conversion in the String class. In general, however, you should
>think hard before you pollute Ruby’s standard libraries with a
>lot of domain-specific methods. After all, a class such as String
>already comes with loads of methods that you have to remember.
>You do have alternatives to using an Open Class (31). You
>could define a new AlphanumericString class or even add specific
>methods like to_alphanumeric( ) only to a few, selected
>strings (you’ll learn how to do that in the discussion of Singleton
>Methods (133)). You’ll learn more Open Class alternatives
>and variations in the rest of this book

    class D
      def y; 'y' ; end
    end
    obj = D.new
    obj.x # => "x"
    obj.y # => "y"

When the previous code mentions class D for the first time, no class
by that name exists yet. So, Ruby steps in and defines the class—and
the x( ) method. At the second mention, class D already exists, so Ruby
doesn’t need to define it. Instead, it just reopens the existing class and
defines a method named y( ) there.

In a sense, the class keyword in Ruby is more like a scope operator than
a class declaration. Yes, it does create classes that don’t yet exist, but
you might argue that it does this as a side effect. For class, the core job is to move you in the context of the class, where you can define methods.

You might think that Bill is just nitpicking here, but this distinction
about the class keyword is not an academic detail. It has an important
practical consequence: you can always reopen existing classes, even
standard library classes such as String or Array, and modify them on the
fly. You can simply call this technique Open Class.

To demonstrate how people use Open Classes in practice, Bill runs
through a quick example from a real-life library.

**The Money Example**

As an example of Open Classes, Bill opens your eyes to the Money gem,
a set of utility classes for managing money and currencies.1 Here’s how
you create a Money object:

    cents = 9999
    # 99.99 US Dollars:
    bargain_price = Money.new(cents)

As a shortcut, you can also convert any number to a Money object by
calling Numeric#to_money( ):

    # 100.00 US Dollars:
    standard_price = 100.to_money()

Since Numeric is a standard Ruby class, you might wonder where the Numeric#to_money method comes from. Look through the source of the Money gem, and you’ll find code that reopens Numeric and defines that method:

    class Numeric
      def to_money
        Money.new(self * 100)
      end
    end

It’s quite common for libraries to use Open Classes this way.

**The Problem with Open Classes**

You and Bill don’t have to look much further before you stumble upon
another opportunity to use Open Classes. The Bookworm source contains
a method that replaces elements in an array.

    def replace(array, from, to)
      array.each_with_index do |e, i|
        array[i] = to if e == from
      end
    end

Instead of focusing on the internal workings of replace( ), you can look
at Bookworm’s unit tests to see how that method is supposed to be
used:

    def test_replace
      book_topics = ['html' , 'java' , 'css' ]
      replace(book_topics, 'java' , 'ruby' )
      expected = ['html' , 'ruby' , 'css' ]
      assert_equal expected, book_topics
    end

This time, you know what to do. You grab the keyboard (taking advantage of Bill’s slower reflexes) and move the method to the Array class:

    class Array
      def replace(from, to)
        each_with_index do |e, i|
          self[i] = to if e == from
        end
      end
    end

Then you change all calls to replace( ) into calls to Array#replace( ). For example, the test becomes as follows:

    def test_replace
      book_topics = ['html' , 'java' , 'css' ]
      book_topics.replace('java' , 'ruby' )
      sexpected = ['html' , 'ruby' , 'css' ]
      assert_equal expected, book_topics
    end

Everything looks like it’s in order until you run Bookworm’s unit tests. Not only do they break, but the failing tests seem to have nothing to do with the code you just edited. Bummer! What gives?

**Monkey See, Monkey Patch**

Your pal Bill comes to the rescue. “I think I know what just happened,” he mumbles. He fires up an irb session and gets a list of all methods in Ruby’s standard Array that begin with re:

    [].methods.grep /^re/ # => [:replace, :reject, :reject!, :respond_to?, ...

Yipes! In looking at the irb output, you spot the problem. Class Array already has a method named replace( ). When you defined your own replace( ) method, you inadvertently overwrote the original replace( ), a method that some other part of Bookworm was relying on.

This is the dark side to Open Classes: if you casually add bits and pieces of functionality to classes, you can end up with bugs like the one you just encountered. Some people would frown upon this kind of reckless patching of classes, and they would refer to the previous code with a derogatory name: they’d call it a *Monkeypatch*. 

You and Bill then rename your own version of Array#replace( ) to Array#substitute( ) and fix both the tests and the calling code. You just learned a lesson the hard way, but that didn’t spoil your attitude. If anything, this incident piqued your curiosity about Ruby classes. As it turns out, Bill is only too happy to tell you more about this topic.
