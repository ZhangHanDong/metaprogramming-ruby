1.3 关于类的真相
---------------------------

*这里，比尔揭示了关于对象，类和常量的惊人事实.*

“现在”， 比尔说， “我们最好还是停止编码休息一下吧， 顺便花点时间来看看Ruby类背后的理论”. 他正襟危坐， “这次一下就是一大堆理论，如果你真想理解Ruby类和对象背后的机制，这部分是必须要学习的，可别偷懒！”

“我想要你集中全部精力，所以我们去找个安静的地方去谈吧。” 他抓起你的胳膊就把你拽进了会议室。

> **Monkeypatching是邪恶的?**

>在前一页1.2节中标题为 Monkey See, Monkey Patch 的那段里， 比尔告诉过你Monkeypatch是一个贬义词。
>然而， 这个词有时也被用在积极场景，一般是指开放类（31页）。你可以认为有两种类型的Monkeypatches (33). 有些导致错误， 像你和比尔经历过的， 而且，它们总是邪恶的。 另外一些则是存心就这么来用， 并且它们十分有用 - 尤其是当你想按需禁用(bend)一个存在的库的时候。

>即使你认为一切都尽在掌握， 你还是应该小心的使用Monkeypatch。 和任何全局性修改类似， 在一个大型的代码库中，Monkeypatches很难被跟踪。 (一些语言使用命名空间选择器（selector namespaces）来解决这个问题, 这种方式就像是被局限到小范围的Monkeypatches. 这种特性可能被Ruby2.0实现，但是还是别报太大期望了。)

>所以, Monkeypatches真是让人又爱又怕. 那么你如何安全的去使用这种方式呢？在你定义你自己的方法之前，要仔细的检查这个类中存在的方法。你应该认识到，某些变化是有更高风险的。例如， 增加一个新方法通常是比修改一个现有方法更安全些。此外，需要彻底的测试你的代码。在232页的9.2节，你将会看到更多管理Monkeypatches的技术

**解剖对象**

“让我们从基础开始：: 对象和类,” 比尔带你到了会议室后随即宣布. 他打开了笔记本， 运行了irb, 开始键入一些代码:

    class MyClass
      def my_method
        @v = 1
      end
    end
    obj = MyClass.new
    obj.class # => MyClass

比尔构建了一个obj对象.如果你能打开Ruby解释器并且调查obj， 你会看到什么？

**实例变量**

最重要的是， 对象包含实例变量。当然你不能真正的去窥视一个对象， 但你能通过调用Object#instance_variables()方法来达到此目的。 比尔的例子只有一个实例变量:

    obj.my_method
    obj.instance_variables # => [:@v]

不像Java或者其他静态语言， Ruby里一个对象的类和它的实例变量之间并没有什么关联。 实例变量只有在当你给它分配了一个值的时候才产生，所以你才能给同一个类对象的实例变量进行不同的设置。

例如，如果比尔还没有调用obj.my_method()方法， 那么obj就根本不会有实例变量存在。你可以把实例变量的名字和值想象为一个hash的键和值。

比尔戏剧化的扬了扬手， 并说 “这真的是我知道关于实例变量的全部了。 现在，让我们移步到方法。”

**方法**

对象除了有'实例变量'之外,还有'方法'。 通过调用Object#methods()方法，你可以得到一个对象的方法列表。 大多数的对象（包括比尔的那个例子），都从Object继承了一批方法，所以这个方法列表通常都十分长。 比尔用了Array#grep()方法去给你显示obj对象方法列表中的my_method()方法:

    obj.methods.grep(/my/) # => [:my_method]

如果你能打开Ruby解释器一探obj的究竟， 你会注意到，这个对象并没有真正的方法列表。在其内部，只包含它的实例变量和一份它的类的引用(准确的说，它也保护一个唯一标识符，返回一个对象的object_id(), 还包含一个标记，来标志对象的状态，例如， “污染tainted”与“冻结frozen”)。那么，方法都在哪呢？

*图 1.1: 实例变量住在对象里面， 方法在住在类里面*

比尔走向会议室的白板，开始在上面写写画画。 “思考一分钟，”他说， 并且画下了图1.1的内容。 “对象共享同一个类，也共享相同的方法， 所以这些方法一定是被存储在类里面，而不是对象中。”

当你看这张图的时候， 比尔不失时机的突出其中的重要区别： 你可以准确的说， “obj有一个叫my_method()的方法，” 这意味着你能这样用 obj.my_method(). 相反，你不能说“MyClass有一个叫my_method()的方法。”这将导致混乱， 因为如果它是一个类的方法， 意味着你能调用MyClass.my_method()。

为了消除歧义，你应该说my_method()是MyClass的一个实例方法（不只是一个方法）， 意味着它是在MyClass中被定义的， 并且你需要一个实例变量才能够调用它。 同样是方法， 但是当你讨论类的时候，就需要叫它实例方法， 当你讨论对象的时候，你可以简单叫它方法。 记住这个区别， 当你写下面这种内省方法的时候就不会那么困扰了:

    String.instance_methods == "abc".methods # => true
    String.methods == "abc".methods # => false

比尔做了一个总结：一个对象的实例变量驻留在对象本身， 一个对象的方法驻留在这个对象的类中。 这就是为什么同一个类的对象共享方法，但是不共享实例变量的原因。

这就是你必须要掌握的关于对象，实例变量和方法的全部。 但是以为他在图1.1中引入了类， 所以比尔建议你看仔细点。

**再探 － 类**

“现在，我们的朋友， 这可能是你学到过关于Ruby对象模型最重要的东西了,” 比尔故作深沉. “就算是类， 也只不过是对象而已。”

因为类是一个对象， 所以适用于对象的一切，也同样适用于类。 类，像任何对象一样， 有它们自己的类。类只是一个叫Class类的实例:

    "hello".class # => String
    String.class # => Class

像任何对象一样， 类也有方法。 记住比尔在34页1.3节提到的，对象是什么？ 一个对象的方法页是它的类的实例方法。 这就意味着一个类的方法也是Class的实例方法:

    inherited = false
    Class.instance_methods(inherited) # => [:superclass, :allocate, :new]

想必你也了解new( ), 因为你一直用它来创建对象。这个allocate( )是new方法的支持方法（译者注：new方法使用allocate来生成实例,使用initialize来完成初始化）, superclass( )，顾名思义， 返回一个类的超类:

    String.superclass # => Object
    Object.superclass # => BasicObject
    BasicObject.superclass # => nil

所有的类最终都继承自Object, 而Object又继承自BasicObject, BasicObject是Ruby的顶级类（注:在Ruby1.9之前， Object是Ruby的顶级类， 但是从Ruby1.9开始，引入了BasicObject, 在89页开始，你会了解为什么会引入这个类）。比尔也给你展示了Class的超类:

    Class.superclass # => Module
    Module.superclass # => Object

所以，一个类只是被三个方法new(), allocate()和superclass()增强的module - 允许你去创建类或者是继承类。除了这些差异（当然是重要的）， 类和模块大致相同。 你将学到的关于类的大部分内容都适用于模块，反之亦然。

*图 1.2: 类只是一个对象*

比尔用白板上的图和代码片段来总结他的类理论:

    class MyClass; end
    obj1 = MyClass.new
    obj2 = MyClass.new

“看到了吗?” 比尔指着图1.2问道，  “类和正常的对象愉快的相处着.”

According to your programming pal, there’s one last wrinkle in the
“Classes are objects” theme: just like you do with regular objects, you
hold onto classes with references. If you look at the previous code, you’ll
see that obj1 and MyClass are both references—the only difference being
that obj1 is a variable, while MyClass is a constant. To put this differently,
just as classes are nothing but objects, class names are nothing
but constants. Bill takes the opportunity to dive into a sermon about
constants.

**Constants**

Any reference that begins with an uppercase letter, including the names
of classes and modules, is a constant. The scope of constants follows 

>**But Aren’t Java Classes Objects, Too?**

>It’s true that classes in both Java and C# are themselves
>instances of a class named Class. C# even allows you to add
>methods to existing classes, pretty much like Ruby’s Open
>Classes (31) do.
>
>However, classes in Java and C# are quite different from, and
>more limited than, regular objects. For example, you can’t create
>a class at runtime, change a class’s methods, or pull most
>other tricks from this book. In a sense, Class objects are more
>like class descriptors than “real” classes, in the same way that
>Java’s File class is a file descriptor rather than the actual file.
>
>This flexibility is typical of Ruby’s metaprogramming: while other
>languages allow you to read class-related information, Ruby
>allows you to write that information at runtime. For example,
>as you will see in Chapter 4, Thursday: Class Definitions, on
>page 122, you can actually call Class.new to create new classes
>at runtime.

>**What Are Modules Good For?**

>In Section 1.3, Classes Revisited, on page 37, you learned that
>a module is basically a bunch of instance methods and that
>a class is just a module with a couple of additional features (a
>superclass and a new( )method). Actually, classes andmodules
>are so closely related that youmight wonder why this distinction
>exists at all. Couldn’t Ruby get away with a single “thing” that
>plays both roles?

>The main reason for having both modules and classes is clarity:
>by carefully picking either a class or a module, you can make
>your code more explicit. Usually, you pick a module when you
>mean it to be included somewhere (or maybe to be used as
>a Namespace (41)), and you pick a class when you mean it to
>be instantiated or inherited. So, although you can use classes
>and modules interchangeably in many situations, you’ll probably
>want to make your intentions clear by using them for different
purposes.

*Figure 1.3: Bill’s napkin drawing of a constants tree*

its own special rules, different from the scope of variables.7 Your pairprogramming partner Bill shows you a quick example:

    module MyModule
      MyConstant = 'Outer constant'
      class MyClass
        MyConstant = 'Inner constant'
      end
    end

Ignoring the whiteboard behind him, Bill picks up a napkin from his
shirt pocket and sketches out the constants in this code (Figure 1.3).
As he points out, all the constants in a program are arranged in a tree
similar to a file system, where modules (and classes) are directories
and regular constants are files. Just like in a file system, you can have
multiple files with the same name, as long as they live in different directories.

You can even refer to a constant by its path, just as you’d do with
a file. For example, you can write MyModule::MyClass::MyConstant

The similarities between Ruby constants and files go even further: you
can use modules to organize your constants, the same way that you use
directories to organize your files. As usual, Bill has an example handy.

**The Rake Example**

The first versions of Rake, the popular Ruby build system, defined classes
with obvious names such as Task and FileTask.9 These names had a
good chance of clashing with other class names from different libraries.
To prevent clashes, recent versions of Rake define the classes inside a
Rake module:

    module Rake
      class Task
      # ...

Now the full name of the Task class is Rake::Task, which is unlikely to
clash with someone else’s name. A module such as Rake, which only
exists to be a container of constants, is called a Namespace. 

What if you have an old Rake build file lying around, one that still references the earlier, non-namespaced class names? To maintain compatibility
with older build files, Rake provides a command-line option
named classic-namespace. This option loads an additional source file
that assigns the new, safer constant names to the old, unsafe ones:

    Task = Rake::Task
    FileTask = Rake::FileTask
    FileCreationTask = Rake::FileCreationTask
    # ...

Now both Task and Rake::Task reference the same Class instance, so you
can use either constant. (Of course, now that you have the old names
around, you have to worry about clashes again—so it would probably
be a good idea to update your build file instead.)

Enough of this digression on constants. It’s time to go back to the focus
of Bill’s improvised lecture—objects and classes—and wrap up what
you’ve just learned.

>**The Paths of Constants**
>In Section 1.3, Constants, on page 38, you learned that constants
>are nested like directories and files. Also like directories
>and files, constants are uniquely identified by their paths. Constants’
>paths use a double colon as a separator (this is akin to
>the scope operator in C++):
>
    module M
      class C
        X = 'a constant'
      end
      C::X # => "a constant"
    end
    M::C::X # => "a constant"
>
>If you’re sitting deep inside the tree of constants, you can provide
>the absolute path to an outer constant by using a leading
>double colon as root:
>
    module M
      Y = 'another constant'
      class C
        ::M::Y # => "another constant"
      end
    end
>
>The Module class also provides an instance method and a class
>method that, confusingly, are both called constants( ). Module#
>constants( ) returns all constants in the current scope, like
>your file system’s ls command (or dir command, if you’re running
>Windows). Module.constants( ) returns all the top-level constants
>in the current program, including class names:
>
    M.constants # => [:C, :Y]
    Module.constants[0..1] # => [:Object, :Module]
>
>Finally, if you need the current path, check out Module.nesting( ):
>
    module M
      class C
        module M2
          Module.nesting # => [M::C::M2, M::C, M]
        end
      end
    end
>

>**Pruning Your Tree of Constants**
>
>Imagine finding a motd.rb file on the Net that displays a “message
>of the day” on the console. You want to incorporate this
>code into your latest program, so you load the file to execute it
>and display the message:
>
    load('motd.rb' )
>
>Using load( ), however, has a side effect. The motd.rb file probably
>defines variables and classes. Although variables fall out of
>scope when the file has finished loading, constants don’t. As a
>result, motd.rb can pollute your program with the names of its
>own constants—in particular, class names.
>You can force motd.rb to keep its constants to itself by passing
>a second, optional argument to load( ):
>
    load('motd.rb' , true)
>
>If you load a file this way, Ruby creates an anonymous module,
>uses that module as a Namespace (41) to contain all the
>constants from motd.rb, and then destroys the module.
The require( )method is quite similar to load( ), but it’smeant for a
different purpose. You use load( ) to execute code, and you use
require( ) to import libraries. That’s why require( ) has no second
argument: those leftover class names are probably the reason
why you imported the file in the first place.

**Objects and Classes Wrap-Up**

What’s an object? It’s just a bunch of instance variables, plus a link to
a class. The object’s methods don’t live in the object—they live in the
object’s class, where they’re called the instance methods of the class.
What’s a class? It’s just an object (an instance of Class), plus a list of
instance methods and a link to a superclass. Class is a subclass of
Module, so a class is also a module.

Like any object, a class has its own methods, such as new( ). These are
instance methods of the Class class. Also like any object, classes must
be accessed through references. You already have a constant reference
to each class: the class’s name.

“That’s pretty much all there is to know about objects and classes,”
Bill asserts. “If you can understand this, you’re well on your way to
understanding metaprogramming. Now, let’s turn back to the code.”

**Another Learning Opportunity**

It takes only a short while for you and Bill to get a chance to apply your
newfound knowledge about classes. After ten minutes sifting through
the Bookworm source code, you stumble upon a class that represents
a snippet of text out of a book:

    class TEXT
      # ...

Since the names of Ruby classes are conventionally camel cased,10 you
and Bill rename this class Text:

    class Text
      # ...

You change the name of the class everywhere it’s used, you run the unit
tests, and—surprise!—the tests fail with a cryptic error message:

    TypeError: Text is not a class

“D’oh! Of course it is,” you exclaim. Bill is as puzzled as you are, so it
takes the two of you some time to find the cause of the problem. As it
turns out, the Bookworm application requires a popular library named
ActionMailer. ActionMailer, in turn, uses a text-formatting library that
defines a module named—you guessed it—Text:

    module Text
      # ...

That’s where the problem lies: since Text is already the name of a module,
Ruby complains that it can’t also be the name of a class at the
same time. In a sense, you were lucky that this name clash was readily
apparent. If ActionMailer’s Text had been a class, you might have
never noticed that this name already existed. Instead, you’d have inadvertently Monkeypatched (33) the existing Text class, with unpredictable
results. (On the other hand, as Bill puts it, “That’s what unit tests
are for.”)

*Figure 1.4: Bill’s object model diagram again*

Fixing the clash between your Text class and ActionMailer’s Text module
is as easy as wrapping your class in a Namespace (41):

    module Bookworm
      class Text
        # ...

You and Bill also change all references to Text into references to Bookworm::
Text. It’s unlikely that an external library defines a class named
Bookworm::Text, so you should be safe from clashes now.

That was a lot of learning in a single sitting! You deserve a break and a
cup of coffee—and a little quiz.